<script type="text/javascript">
	var Roblox = Roblox || {};

	Roblox.BundleVerifierConstants = {
		isMetricsApiEnabled: true,
		eventStreamUrl: '//<%= urlMetadata.Hosts.EphemeralCountersV2 %>/pe?t=diagnostic',
		deviceType: 'Computer',
		cdnLoggingEnabled: JSON.parse('true'),
	};
	//# sourceURL=bundleVerifierConstants.js
</script>
<script type="text/javascript">
	var Roblox = Roblox || {};

	Roblox.BundleDetector = (function () {
		var isMetricsApiEnabled = Roblox.BundleVerifierConstants && Roblox.BundleVerifierConstants.isMetricsApiEnabled;

		var loadStates = {
			loadSuccess: 'loadSuccess',
			loadFailure: 'loadFailure',
			executionFailure: 'executionFailure',
		};

		var bundleContentTypes = {
			javascript: 'javascript',
			css: 'css',
		};

		var ephemeralCounterNames = {
			cdnPrefix: 'CDNBundleError_',
			unknown: 'CDNBundleError_unknown',
			cssError: 'CssBundleError',
			jsError: 'JavascriptBundleError',
			jsFileError: 'JsFileExecutionError',
			resourceError: 'ResourcePerformance_Error',
			resourceLoaded: 'ResourcePerformance_Loaded',
		};

		return {
			jsBundlesLoaded: {},
			bundlesReported: {},

			counterNames: ephemeralCounterNames,
			loadStates: loadStates,
			bundleContentTypes: bundleContentTypes,

			timing: undefined,

			setTiming: function (windowTiming) {
				this.timing = windowTiming;
			},

			getLoadTime: function () {
				if (this.timing && this.timing.domComplete) {
					return this.getCurrentTime() - this.timing.domComplete;
				}
			},

			getCurrentTime: function () {
				return new Date().getTime();
			},

			getCdnProviderName: function (bundleUrl, callBack) {
				if (Roblox.BundleVerifierConstants.cdnLoggingEnabled) {
					var xhr = new XMLHttpRequest();
					xhr.open('GET', bundleUrl, true);

					xhr.onreadystatechange = function () {
						if (xhr.readyState === xhr.HEADERS_RECEIVED) {
							try {
								var headerValue = xhr.getResponseHeader('rbx-cdn-provider');
								if (headerValue) {
									callBack(headerValue);
								} else {
									callBack();
								}
							} catch (e) {
								callBack();
							}
						}
					};

					xhr.onerror = function () {
						callBack();
					};

					xhr.send();
				} else {
					callBack();
				}
			},

			getCdnProviderAndReportMetrics: function (bundleUrl, bundleName, loadState, bundleContentType) {
				this.getCdnProviderName(bundleUrl, function (cdnProviderName) {
					Roblox.BundleDetector.reportMetrics(bundleUrl, bundleName, loadState, bundleContentType, cdnProviderName);
				});
			},

			reportMetrics: function (bundleUrl, bundleName, loadState, bundleContentType, cdnProviderName) {
				if (
					!isMetricsApiEnabled ||
					!bundleUrl ||
					!loadState ||
					!loadStates.hasOwnProperty(loadState) ||
					!bundleContentType ||
					!bundleContentTypes.hasOwnProperty(bundleContentType)
				) {
					return;
				}

				var xhr = new XMLHttpRequest();
				var metricsApiUrl =
					(Roblox.EnvironmentUrls && Roblox.EnvironmentUrls.metricsApi) || 'https://<%= urlMetadata.Hosts.MetricsHost %>';

				xhr.open('POST', metricsApiUrl + '/v1/bundle-metrics/report', true);
				xhr.setRequestHeader('Content-Type', 'application/json');
				xhr.withCredentials = true;
				xhr.send(
					JSON.stringify({
						bundleUrl: bundleUrl,
						bundleName: bundleName || '',
						bundleContentType: bundleContentType,
						loadState: loadState,
						cdnProviderName: cdnProviderName,
						loadTimeInMilliseconds: this.getLoadTime() || 0,
					}),
				);
			},

			logToEphemeralStatistics: function (sequenceName, value) {
				var deviceType = Roblox.BundleVerifierConstants.deviceType;
				sequenceName += '_' + deviceType;

				var xhr = new XMLHttpRequest();
				xhr.open('POST', '/game/report-stats?name=' + sequenceName + '&value=' + value, true);
				xhr.withCredentials = true;
				xhr.send();
			},

			logToEphemeralCounter: function (ephemeralCounterName) {
				var deviceType = Roblox.BundleVerifierConstants.deviceType;
				ephemeralCounterName += '_' + deviceType;
				//log to ephemeral counters - taken from eventTracker.js
				var xhr = new XMLHttpRequest();
				xhr.open('POST', '/game/report-event?name=' + ephemeralCounterName, true);
				xhr.withCredentials = true;
				xhr.send();
			},

			logToEventStream: function (failedBundle, ctx, cdnProvider, status) {
				var esUrl = Roblox.BundleVerifierConstants.eventStreamUrl,
					currentPageUrl = encodeURIComponent(window.location.href);

				var deviceType = Roblox.BundleVerifierConstants.deviceType;
				ctx += '_' + deviceType;
				//try and grab performance data.
				//Note that this is the performance of the xmlhttprequest rather than the original resource load.
				var duration = 0;
				if (window.performance) {
					var perfTiming = window.performance.getEntriesByName(failedBundle);
					if (perfTiming.length > 0) {
						var data = perfTiming[0];
						duration = data.duration || 0;
					}
				}
				//log to event stream (diagnostic)
				var params =
					'&evt=webBundleError&url=' +
					currentPageUrl +
					'&ctx=' +
					ctx +
					'&fileSourceUrl=' +
					encodeURIComponent(failedBundle) +
					'&cdnName=' +
					(cdnProvider || 'unknown') +
					'&statusCode=' +
					(status || 'unknown') +
					'&loadDuration=' +
					Math.floor(duration);
				var img = new Image();
				img.src = esUrl + params;
			},

			getCdnInfo: function (failedBundle, ctx, fileType) {
				if (Roblox.BundleVerifierConstants.cdnLoggingEnabled) {
					var xhr = new XMLHttpRequest();
					var counter = this.counterNames;
					xhr.open('GET', failedBundle, true);
					var cdnProvider;

					//succesful request
					xhr.onreadystatechange = function () {
						if (xhr.readyState === xhr.HEADERS_RECEIVED) {
							cdnProvider = xhr.getResponseHeader('rbx-cdn-provider');
							if (cdnProvider && cdnProvider.length > 0) {
								Roblox.BundleDetector.logToEphemeralCounter(counter.cdnPrefix + cdnProvider + '_' + fileType);
							} else {
								Roblox.BundleDetector.logToEphemeralCounter(counter.unknown + '_' + fileType);
							}
						} else if (xhr.readyState === xhr.DONE) {
							// append status to cdn provider so we know its not related to network error.
							Roblox.BundleDetector.logToEventStream(failedBundle, ctx, cdnProvider, xhr.status);
						}
					};

					//attach to possible things that can go wrong with the request.
					//additionally a network error will trigger this callback
					xhr.onerror = function () {
						Roblox.BundleDetector.logToEphemeralCounter(counter.unknown + '_' + fileType);
						Roblox.BundleDetector.logToEventStream(failedBundle, ctx, counter.unknown);
					};

					xhr.send();
				} else {
					this.logToEventStream(failedBundle, ctx);
				}
			},

			reportResourceError: function (resourceName) {
				var ephemeralCounterName = this.counterNames.resourceError + '_' + resourceName;
				this.logToEphemeralCounter(ephemeralCounterName);
			},

			reportResourceLoaded: function (resourceName) {
				var loadTimeInMs = this.getLoadTime();
				if (loadTimeInMs) {
					var sequenceName = this.counterNames.resourceLoaded + '_' + resourceName;
					this.logToEphemeralStatistics(sequenceName, loadTimeInMs);
				}
			},

			reportBundleError: function (bundleTag) {
				var ephemeralCounterName, failedBundle, ctx, contentType;
				if (bundleTag.rel && bundleTag.rel === 'stylesheet') {
					ephemeralCounterName = this.counterNames.cssError;
					failedBundle = bundleTag.href;
					ctx = 'css';
					contentType = bundleContentTypes.css;
				} else {
					ephemeralCounterName = this.counterNames.jsError;
					failedBundle = bundleTag.src;
					ctx = 'js';
					contentType = bundleContentTypes.javascript;
				}

				//mark that we logged this bundle
				this.bundlesReported[failedBundle] = true;

				//e.g. javascriptBundleError_Computer
				this.logToEphemeralCounter(ephemeralCounterName);
				//this will also log to event stream
				this.getCdnInfo(failedBundle, ctx, ctx);

				var bundleName;
				if (bundleTag.dataset) {
					bundleName = bundleTag.dataset.bundlename;
				} else {
					bundleName = bundleTag.getAttribute('data-bundlename');
				}

				this.getCdnProviderAndReportMetrics(failedBundle, bundleName, loadStates.loadFailure, contentType);
			},

			bundleDetected: function (bundleName) {
				this.jsBundlesLoaded[bundleName] = true;
			},

			verifyBundles: function (document) {
				var ephemeralCounterName = this.counterNames.jsFileError,
					eventContext = ephemeralCounterName;
				//grab all roblox script tags in the page.
				var scripts = (document && document.scripts) || window.document.scripts;
				var errorsList = [];
				var bundleName;
				var monitor;
				for (var i = 0; i < scripts.length; i++) {
					var item = scripts[i];

					if (item.dataset) {
						bundleName = item.dataset.bundlename;
						monitor = item.dataset.monitor;
					} else {
						bundleName = item.getAttribute('data-bundlename');
						monitor = item.getAttribute('data-monitor');
					}

					if (item.src && monitor && bundleName) {
						if (!Roblox.BundleDetector.jsBundlesLoaded.hasOwnProperty(bundleName)) {
							errorsList.push(item);
						}
					}
				}
				if (errorsList.length > 0) {
					for (var j = 0; j < errorsList.length; j++) {
						var script = errorsList[j];
						if (!this.bundlesReported[script.src]) {
							//log the counter only if the file is actually corrupted, not just due to failure to load
							//e.g. JsFileExecutionError_Computer
							this.logToEphemeralCounter(ephemeralCounterName);
							this.getCdnInfo(script.src, eventContext, 'js');

							if (script.dataset) {
								bundleName = script.dataset.bundlename;
							} else {
								bundleName = script.getAttribute('data-bundlename');
							}

							this.getCdnProviderAndReportMetrics(
								script.src,
								bundleName,
								loadStates.executionFailure,
								bundleContentTypes.javascript,
							);
						}
					}
				}
			},
		};
	})();

	window.addEventListener('load', function (evt) {
		Roblox.BundleDetector.verifyBundles();
	});

	Roblox.BundleDetector.setTiming(window.performance.timing);
	//# sourceURL=bundleDetectorBase.js
</script>
